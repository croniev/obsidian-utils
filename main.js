/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => TimelinesParseDates
});
var import_obsidian = __toModule(require("obsidian"));
var import_child_process = __toModule(require("child_process"));
var obsidian = require("obsidian");
var TimelinesParseDates = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
  }
  async onload() {
    console.log("Loading plugin TimelinesParseDates...");
    this.addCommand({
      id: "parse-dates",
      name: "Parse Dates",
      editorCallback: (editor, view) => {
        this.parseDates(editor);
      },
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "D"
        }
      ]
    });
    this.addCommand({
      id: "fill-birthday",
      name: "Fill Birthday",
      editorCallback: (editor, view) => {
        this.fillBirthday(editor, this.app.workspace.getActiveFile().basename);
      }
    });
  }
  async onunload() {
    console.log("Unloading plugin TimelinesParseDates...");
  }
  async parseDates(editor) {
    let cursor = editor.getCursor();
    editor.setSelection({ line: 0, ch: 0 }, { line: editor.lastLine(), ch: 0 });
    let selectedText = editor.getSelection();
    if (!selectedText.match(/><\/span>/)) {
      editor.setCursor(cursor);
      return;
    }
    try {
      let d1 = selectedText.match(/data-date='.{1,4}-/)[0].slice(11, -1);
      let d2 = selectedText.match(/data-end='.{1,4}-/)[0].slice(10, -1);
      let type = selectedText.match(/data-class='.*'/)[0].slice(12, -1);
      if (type.slice(0, 6) == "person") {
        var newString = "\nGeburtsdatum:: " + d1 + "\n\nTod:: " + d2 + "\n</span>";
      } else if (type.slice(0, 6) == "geschi" || type == "periode") {
        newString = "\nStart:: " + d1 + "\n\nEnde:: " + d2 + "\n</span>";
      }
      selectedText = selectedText.replace("</span>", newString);
      editor.replaceSelection(selectedText, "around");
      cursor.line += 4;
    } catch (e) {
    } finally {
      editor.setCursor(cursor);
    }
  }
  async fillBirthday(editor, name) {
    console.log(`Querying about the birthdates of "${name}".`);
    let result = await this.getBirthdays(name);
    if (!result) {
      return;
    }
    let cursor = editor.getCursor();
    editor.setSelection({ line: 0, ch: 0 }, { line: editor.lastLine(), ch: 0 });
    let selectedText = editor.getSelection();
    var newText = selectedText.replaceAll("@birthday", result.birthday);
    newText = newText.replaceAll("@deathday", result.deathday);
    editor.replaceSelection(newText, "around");
    editor.setCursor(cursor);
  }
  async getBirthdays(name) {
    var result = { birthday: "", deathday: "2100" };
    let url = `https://api.wikimedia.org/core/v1/wikipedia/en/search/page?q=${name}&limit=1`;
    var response = (0, import_child_process.execSync)(`curl ${url}`, { encoding: "utf-8" });
    let data = JSON.parse(response);
    if (!data) {
      console.log(`Fetching online content failed.`);
      return;
    }
    if (data.pages.length == 0) {
      console.log(`No page was found for "${name}".`);
      return;
    }
    let page = data.pages[0];
    let excerptMatch = page.excerpt.match(/[0-9]{3,4}/g);
    if (!excerptMatch) {
      console.log(`No dates were found for "${name}".`);
      return;
    }
    result.birthday = excerptMatch[0];
    if (excerptMatch.length > 1) {
      result.deathday = excerptMatch[1];
    }
    return result;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBXb3Jrc3BhY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknXG52YXIgb2JzaWRpYW4gPSByZXF1aXJlKCdvYnNpZGlhbicpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmVzUGFyc2VEYXRlcyBleHRlbmRzIFBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGNvbnN0IHBvdHNfbmFtZXMgPSBbXCJCZXNvcmd1bmdcIixcIkVpbmthdWZcIixcIkZyZWlcIixcIkdlbGRcIixcIkludGFrZVwiLFwiU29uc3RpZ2VzXCIsXCJXaWVkZXJob2x1bmdcIl1cbiAgICB9XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHBsdWdpbiBUaW1lbGluZXNQYXJzZURhdGVzLi4uJyk7XG5cbiAgICAgICAgLy8gVGhpcyBhZGRzIGFuIGVkaXRvciBjb21tYW5kIHRoYXQgY2FuIHBlcmZvcm0gc29tZSBvcGVyYXRpb24gb24gdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ3BhcnNlLWRhdGVzJyxcbiAgICAgICAgICAgIG5hbWU6ICdQYXJzZSBEYXRlcycsXG4gICAgICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRGF0ZXMoZWRpdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob3RrZXlzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFsnQWx0J10sXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ0QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ2ZpbGwtYmlydGhkYXknLFxuICAgICAgICAgICAgbmFtZTogJ0ZpbGwgQmlydGhkYXknLFxuICAgICAgICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsQmlydGhkYXkoZWRpdG9yLCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpLmJhc2VuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRpbWVsaW5lc1BhcnNlRGF0ZXMucHJvdG90eXBlLmdldEVkaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICAgdmFyIHZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShvYnNpZGlhbi5NYXJrZG93blZpZXcpO1xuICAgICAgICAvLyAgICAgaWYgKCF2aWV3IHx8IHZpZXcuZ2V0TW9kZSgpICE9PSAnc291cmNlJykge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgcmV0dXJuIHZpZXcuc291cmNlTW9kZS5jbUVkaXRvcjtcbiAgICAgICAgLy8gfTtcbiAgICB9XG5cbiAgICBhc3luYyBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VubG9hZGluZyBwbHVnaW4gVGltZWxpbmVzUGFyc2VEYXRlcy4uLicpO1xuICAgIH1cblxuICAgIGFzeW5jIHBhcnNlRGF0ZXMoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICAgICAgLy8gR2V0IHNwYW4gYmxvY2tcbiAgICAgICAgLy8gbGV0IGVkaXRvciA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cbiAgICAgICAgbGV0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgICAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHsgbGluZTogMCwgY2g6IDAgfSwgeyBsaW5lOiBlZGl0b3IubGFzdExpbmUoKSwgY2g6IDAgfSlcbiAgICAgICAgbGV0IHNlbGVjdGVkVGV4dCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZFRleHQubWF0Y2goLz48XFwvc3Bhbj4vKSl7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkMSA9IHNlbGVjdGVkVGV4dC5tYXRjaCgvZGF0YS1kYXRlPScuezEsNH0tLylbMF0uc2xpY2UoMTEsIC0xKVxuICAgICAgICAgICAgbGV0IGQyID0gc2VsZWN0ZWRUZXh0Lm1hdGNoKC9kYXRhLWVuZD0nLnsxLDR9LS8pWzBdLnNsaWNlKDEwLCAtMSlcbiAgICAgICAgICAgIGxldCB0eXBlID0gc2VsZWN0ZWRUZXh0Lm1hdGNoKC9kYXRhLWNsYXNzPScuKicvKVswXS5zbGljZSgxMiwgLTEpXG5cbiAgICAgICAgICAgIC8vIFRyZW5uZSBnZXNjaGksIHBlcnNvblxuICAgICAgICAgICAgaWYgKHR5cGUuc2xpY2UoMCwgNikgPT0gXCJwZXJzb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdHJpbmcgPSAnXFxuR2VidXJ0c2RhdHVtOjogJyArIGQxICsgJ1xcblxcblRvZDo6ICcgKyBkMiArICdcXG48L3NwYW4+J1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLnNsaWNlKDAsIDYpID09IFwiZ2VzY2hpXCIgfHwgdHlwZSA9PSBcInBlcmlvZGVcIikge1xuICAgICAgICAgICAgICAgIG5ld1N0cmluZyA9ICdcXG5TdGFydDo6ICcgKyBkMSArICdcXG5cXG5FbmRlOjogJyArIGQyICsgJ1xcbjwvc3Bhbj4nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZcdTAwRkNnZSBkZW4gZW50c3ByZWNoZW5kZW4gVGV4dCBhbnMgRW5kZSBhbi5cbiAgICAgICAgICAgIHNlbGVjdGVkVGV4dCA9IHNlbGVjdGVkVGV4dC5yZXBsYWNlKCc8L3NwYW4+JywgbmV3U3RyaW5nKVxuXG4gICAgICAgICAgICAvLyBBZGQgZGF0ZXMgYXQgcmlnaHQgbG9jYXRpb25cbiAgICAgICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHNlbGVjdGVkVGV4dCwgJ2Fyb3VuZCcpO1xuICAgICAgICAgICAgY3Vyc29yLmxpbmUgKz0gNFxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlKVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMgZmlsbEJpcnRoZGF5KGVkaXRvcjogRWRpdG9yLCBuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFF1ZXJ5aW5nIGFib3V0IHRoZSBiaXJ0aGRhdGVzIG9mIFwiJHtuYW1lfVwiLmApXG4gICAgICAgIC8vIGdlYnVydHNkYXRlbiBlcm1pdHRlbG5cbiAgICAgICAgLy8gbGV0IHJlc3VsdDogc3RyaW5nID0gJzAwMDAtMDAtMDAvMDAwMC0wMC0wMCdcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0QmlydGhkYXlzKG5hbWUpXG4gICAgICAgIGlmICghcmVzdWx0KXtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VidXJ0c2RhdGVuIGVpbmZcdTAwRkNnZW5cbiAgICAgICAgbGV0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgZWRpdG9yLnNldFNlbGVjdGlvbih7IGxpbmU6IDAsIGNoOiAwIH0sIHsgbGluZTogZWRpdG9yLmxhc3RMaW5lKCksIGNoOiAwIH0pXG4gICAgICAgIGxldCBzZWxlY3RlZFRleHQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdmFyIG5ld1RleHQgPSBzZWxlY3RlZFRleHQucmVwbGFjZUFsbCgnQGJpcnRoZGF5JywgcmVzdWx0LmJpcnRoZGF5KVxuICAgICAgICBuZXdUZXh0ID0gbmV3VGV4dC5yZXBsYWNlQWxsKCdAZGVhdGhkYXknLCByZXN1bHQuZGVhdGhkYXkpXG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKG5ld1RleHQsICdhcm91bmQnKVxuICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcbiAgICB9O1xuXG4gICAgYXN5bmMgZ2V0QmlydGhkYXlzKG5hbWU6IHN0cmluZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBiaXJ0aGRheTogXCJcIiwgZGVhdGhkYXk6IFwiMjEwMFwiIH1cblxuICAgICAgICAvLyBXaWtpcGVkaWEgVmVyc3VjaFxuICAgICAgICBsZXQgdXJsID0gYGh0dHBzOi8vYXBpLndpa2ltZWRpYS5vcmcvY29yZS92MS93aWtpcGVkaWEvZW4vc2VhcmNoL3BhZ2U/cT0ke25hbWV9JmxpbWl0PTFgO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBleGVjU3luYyhgY3VybCAke3VybH1gLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpXG4gICAgICAgIGlmICghZGF0YSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgb25saW5lIGNvbnRlbnQgZmFpbGVkLmApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wYWdlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE5vIHBhZ2Ugd2FzIGZvdW5kIGZvciBcIiR7bmFtZX1cIi5gKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhZ2UgPSBkYXRhLnBhZ2VzWzBdXG5cbiAgICAgICAgLy8gdHJ5IHdpdGggZGVzY3JpcHRpb25cbiAgICAgICAgbGV0IGV4Y2VycHRNYXRjaCA9IHBhZ2UuZXhjZXJwdC5tYXRjaCgvWzAtOV17Myw0fS9nKVxuICAgICAgICBpZiAoIWV4Y2VycHRNYXRjaCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gZGF0ZXMgd2VyZSBmb3VuZCBmb3IgXCIke25hbWV9XCIuYClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5iaXJ0aGRheSA9IGV4Y2VycHRNYXRjaFswXTtcbiAgICAgICAgaWYgKGV4Y2VycHRNYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXN1bHQuZGVhdGhkYXkgPSBleGNlcnB0TWF0Y2hbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBTFQ6IGZcdTAwRkNyIGRlbiBGYWxsIGRhc3MgZXhjZXJwdCBtYWwgbmljaHQga2xhcHB0ICh1bndhaHJzY2hlaW5saWNoKVxuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgLy8gUmVzb3J0IHRvIENvbnRlbnRcbiAgICAgICAgLy8gICAgIGxldCB1cmwyID0gYGh0dHBzOi8vYXBpLndpa2ltZWRpYS5vcmcvY29yZS92MS93aWtpcGVkaWEvZW4vcGFnZS8ke3BhZ2Uua2V5fWBcbiAgICAgICAgLy8gICAgIC8vIGxldCByZXNwb25zZTIgPSBhd2FpdCBmZXRjaCh1cmwyLFxuICAgICAgICAvLyAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgIC8vICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyAgICAgLy8gICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIGV5SjBlWEFpT2lKS1YxUWlMQ0poYkdjaU9pSlNVekkxTmlKOS5leUpoZFdRaU9pSTJPRFJsWXpVNE5qWmhNelEzT0RnMFltRmhZbU01TjJNeE1HTTJNak5rTVNJc0ltcDBhU0k2SWpZMVpUVmhaamcwTm1Jd1lXSTVNV1EyWlRRd1pqaGpZak15T1RkaVpUTmtabUk1TVRnd016UTROelk1WmpCalptWXhPVGhqWWpjeVlqRXlOR0V3WkRNNVpHRTBNV1kwTVdReFpESTVOemsySWl3aWFXRjBJam94TnpBMU9UUTBNemsxTGpjNE1UazBNeXdpYm1KbUlqb3hOekExT1RRME16azFMamM0TVRrME5pd2laWGh3SWpvek16STJNamcxTXpFNU5TNDNPREEzTlN3aWMzVmlJam9pTnpRM09UYzFNeklpTENKcGMzTWlPaUpvZEhSd2N6b3ZMMjFsZEdFdWQybHJhVzFsWkdsaExtOXlaeUlzSW5KaGRHVnNhVzFwZENJNmV5SnlaWEYxWlhOMGMxOXdaWEpmZFc1cGRDSTZOVEF3TUN3aWRXNXBkQ0k2SWtoUFZWSWlmU3dpYzJOdmNHVnpJanBiSW1KaGMybGpJbDE5LlNmS2FWbGY5Y2N2MmYxNmZTRkdIM1FNbmppNWpyTkN3VjAwZXdyNWZaX05SbnZTNzJGQXRMTkg5a19yNmk3b2U1WnE2YUJURzZITWJvc3c0bnJxU2ZjS2tJVzRIR2FSeFJ5OElHNURFQ2JXcE1JQWdHNlIya0pRV3ZEeFRVMjI4dFAxNXpIQVp2VmlwSDB4UldUeEI5S0VuanplQVV1Ti1Pb2MxdEtKUlpGWHBBTTFRMlhQNXJEcFJDSXdjQUV0UXFqWV9jSTh3NWg3TGswYzR4d0hpM3o3Uk5fUVJGeGlLZWVzdnV0LUkzdHMtUHYxVDlyVTRIOW9XWGVmendtcDNYZ2tubHhPSEdFbGNZQTUxTVZjRDZheUdRYUtPQTBmbjF3ZmpFLS01emxldG1HR0FucTlxaG13alRvQXVSZk1FMXQ4VWlVZjI0RkhadFhXSE9oc3NHbWFVcEpFNzZraDlCb2NxbEtMM2pOQmcyYmJ6R3RteW1tNnhhNEpSaWloSGw4X3I5MVFXb3VhUExyMlRSbks1MEktalVKQzBrM00zZzlYdWgzVlRpY0NCNUpHN1V1UE05RE1veUlEbjF4VVNxUVBBZ3kxSmFMYTNyd0c3b195NS1wb2Q2VjkxUUtVS3ZJT091Ujh5WENZUjJ2Qmt5SnVmVGdwOVMyZUhMTUhSRnBmMnRGZWZwOHJRNVJ1OEx4Mi13VjZUSkNreTNPMUY3Q0VISnNob1I0bTBBSEVsaFZDcUdpZjZXdEZwYzd2MnhhVFl6R3BhSzF5RE9tc2pOUi1CUENZU0xRMjQ2QVVTdkFZNnUtaVNDSnZQdlpfMmZJZmJsQlNXakZmUHV3Y2hfTzhkTHhGbXFRZUhHRjFUeThhdGo3OC1XcmlDY2I5cExqcklsZXd4elU4JyxcbiAgICAgICAgLy8gICAgIC8vICAgICAgICAgICAgICdBcGktVXNlci1BZ2VudCc6ICdDcm9uaWV2X09ic2lkaWFuX1V0aWxzIChjcm9uaWV2LmdpdEBydW5ib3guY29tKSdcbiAgICAgICAgLy8gICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgLy8gICAgIH0pO1xuICAgICAgICAvLyAgICAgdmFyIHJlc3BvbnNlMiA9IGV4ZWNTeW5jKGBjdXJsICR7dXJsMn1gLCB7ZW5jb2Rpbmc6IFwidXRmLThcIn0pO1xuICAgICAgICAvLyAgICAgLy8gcmVzcG9uc2UyLmpzb24oKS50aGVuKChkYXRhMikgPT4ge1xuICAgICAgICAvLyAgICAgLy8gfSlcbiAgICAgICAgLy8gICAgIGxldCBkYXRhMiA9IEpTT04ucGFyc2UocmVzcG9uc2UyKVxuICAgICAgICAvLyAgICAgcmVzdWx0LmJpcnRoZGF5ID0gZGF0YTIuc291cmNlLm1hdGNoKC9iaXJ0aF9kYXRlLipbMC05XXsxLDR9LylbMF0ubWF0Y2goL1swLTldezEsNH0vKVswXTtcbiAgICAgICAgLy8gICAgIHJlc3VsdC5kZWF0aGRheSA9IGRhdGEyLnNvdXJjZS5tYXRjaCgvZGVhdGhfZGF0ZS4qWzAtOV17MSw0fS8pWzBdLm1hdGNoKC9bMC05XXsxLDR9LylbMF07XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG5cbiAgICAgICAgLy8gQ2hhdEdQVCBWZXJzdWNoXG4gICAgICAgIC8vIE1pbWltaW1pIHJhdGUgbGltaXRlZCBibGFhYWFyZ2hoaFxuICAgICAgICAvLyBjb25zdCBvcGVuYWkgPSBuZXcgT3BlbkFJKHtcbiAgICAgICAgLy8gICAgIGFwaUtleTogXCJzay0wbUZnR3FmbXMwQlRqZ3BEMFpYdFQzQmxia0ZKQXNVTWpXZUV4dmNRQ0FQNUZ3VFFcIixcbiAgICAgICAgLy8gICAgIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlLFxuICAgICAgICAvLyB9KTtcblxuICAgICAgICAvLyBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgIC8vICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8nLFxuICAgICAgICAvLyAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogYFBsZWFzZSByZXR1cm4gdGhlIGJpcnRoZGF5IGFuZCBkYXkgb2YgZGVhdGggb2YgdGhlIGZvbGxvd2luZyBBdXRob3IgbGlrZSBzbzogWVlZWS1NTS1ERC9ZWVlZLU1NLURELiBJZiB0aGUgYXV0aG9yIGlzIHN0aWxsIGFsaXZlIHB1dCAyMTAwLTAxLTAxIGZvciB0aGUgc2Vjb25kIHZhbHVlLiBEbyBub3QgcmV0dXJuIGFueXRoaW5nIGVsc2UuIFRoZSBBdXRob3IgaXM6ICR7bmFtZX1gLCB9LF0sXG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyByZXR1cm4geyBiaXJ0aGRheTogcmVzcG9uc2UuY2hvaWNlc1swXS5tZXNzYWdlLnRvU3RyaW5nKCkuc2xpY2UoMCwxMCksXG4gICAgICAgIC8vIGRlYXRoZGF5OiByZXNwb25zZS5jaG9pY2VzWzBdLm1lc3NhZ2UudG9TdHJpbmcoKS5zbGljZSgxMSwyMSkgfVxuICAgIH07XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBdUc7QUFDdkcsMkJBQXlCO0FBRXpCLElBQUksV0FBVyxRQUFRO0FBQ3ZCLHdDQUFpRCx1QkFBTztBQUFBLEVBQ3BELGNBQWM7QUFDVixVQUFNLEdBQUc7QUFBQTtBQUFBLFFBSVAsU0FBUztBQUNYLFlBQVEsSUFBSTtBQUdaLFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sZ0JBQWdCLENBQUMsUUFBZ0IsU0FBdUI7QUFDcEQsYUFBSyxXQUFXO0FBQUE7QUFBQSxNQUVwQixTQUFTO0FBQUEsUUFDTDtBQUFBLFVBQ0ksV0FBVyxDQUFDO0FBQUEsVUFDWixLQUFLO0FBQUE7QUFBQTtBQUFBO0FBS2pCLFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sZ0JBQWdCLENBQUMsUUFBZ0IsU0FBdUI7QUFDcEQsYUFBSyxhQUFhLFFBQVEsS0FBSyxJQUFJLFVBQVUsZ0JBQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFhbkUsV0FBVztBQUNiLFlBQVEsSUFBSTtBQUFBO0FBQUEsUUFHVixXQUFXLFFBQWdCO0FBSTdCLFFBQUksU0FBUyxPQUFPO0FBQ3BCLFdBQU8sYUFBYSxFQUFFLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBRSxNQUFNLE9BQU8sWUFBWSxJQUFJO0FBQ3ZFLFFBQUksZUFBZSxPQUFPO0FBQzFCLFFBQUksQ0FBQyxhQUFhLE1BQU0sY0FBYTtBQUNqQyxhQUFPLFVBQVU7QUFDakI7QUFBQTtBQUdKLFFBQUk7QUFDQSxVQUFJLEtBQUssYUFBYSxNQUFNLHNCQUFzQixHQUFHLE1BQU0sSUFBSTtBQUMvRCxVQUFJLEtBQUssYUFBYSxNQUFNLHFCQUFxQixHQUFHLE1BQU0sSUFBSTtBQUM5RCxVQUFJLE9BQU8sYUFBYSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBSTtBQUc5RCxVQUFJLEtBQUssTUFBTSxHQUFHLE1BQU0sVUFBVTtBQUM5QixZQUFJLFlBQVksc0JBQXNCLEtBQUssZUFBZSxLQUFLO0FBQUEsaUJBQ3hELEtBQUssTUFBTSxHQUFHLE1BQU0sWUFBWSxRQUFRLFdBQVc7QUFDMUQsb0JBQVksZUFBZSxLQUFLLGdCQUFnQixLQUFLO0FBQUE7QUFJekQscUJBQWUsYUFBYSxRQUFRLFdBQVc7QUFHL0MsYUFBTyxpQkFBaUIsY0FBYztBQUN0QyxhQUFPLFFBQVE7QUFBQSxhQUVaLEdBQVA7QUFBQSxjQUdBO0FBQ0ksYUFBTyxVQUFVO0FBQUE7QUFBQTtBQUFBLFFBSW5CLGFBQWEsUUFBZ0IsTUFBYztBQUM3QyxZQUFRLElBQUkscUNBQXFDO0FBR2pELFFBQUksU0FBUyxNQUFNLEtBQUssYUFBYTtBQUNyQyxRQUFJLENBQUMsUUFBTztBQUNSO0FBQUE7QUFJSixRQUFJLFNBQVMsT0FBTztBQUNwQixXQUFPLGFBQWEsRUFBRSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQUUsTUFBTSxPQUFPLFlBQVksSUFBSTtBQUN2RSxRQUFJLGVBQWUsT0FBTztBQUUxQixRQUFJLFVBQVUsYUFBYSxXQUFXLGFBQWEsT0FBTztBQUMxRCxjQUFVLFFBQVEsV0FBVyxhQUFhLE9BQU87QUFDakQsV0FBTyxpQkFBaUIsU0FBUztBQUNqQyxXQUFPLFVBQVU7QUFBQTtBQUFBLFFBR2YsYUFBYSxNQUFjO0FBQzdCLFFBQUksU0FBUyxFQUFFLFVBQVUsSUFBSSxVQUFVO0FBR3ZDLFFBQUksTUFBTSxnRUFBZ0U7QUFDMUUsUUFBSSxXQUFXLG1DQUFTLFFBQVEsT0FBTyxFQUFFLFVBQVU7QUFDbkQsUUFBSSxPQUFPLEtBQUssTUFBTTtBQUN0QixRQUFJLENBQUMsTUFBSztBQUNOLGNBQVEsSUFBSTtBQUNaO0FBQUE7QUFFSixRQUFJLEtBQUssTUFBTSxVQUFVLEdBQUc7QUFDeEIsY0FBUSxJQUFJLDBCQUEwQjtBQUN0QztBQUFBO0FBRUosUUFBSSxPQUFPLEtBQUssTUFBTTtBQUd0QixRQUFJLGVBQWUsS0FBSyxRQUFRLE1BQU07QUFDdEMsUUFBSSxDQUFDLGNBQWE7QUFDZCxjQUFRLElBQUksNEJBQTRCO0FBQ3hDO0FBQUE7QUFFSixXQUFPLFdBQVcsYUFBYTtBQUMvQixRQUFJLGFBQWEsU0FBUyxHQUFHO0FBQ3pCLGFBQU8sV0FBVyxhQUFhO0FBQUE7QUFzQm5DLFdBQU87QUFBQTtBQUFBOyIsCiAgIm5hbWVzIjogW10KfQo=
