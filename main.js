/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => TimelinesParseDates
});
var import_obsidian = __toModule(require("obsidian"));
var obsidian = require("obsidian");
var TimelinesParseDates = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
  }
  onload() {
    return __async(this, null, function* () {
      console.log("Loading plugin TimelinesParseDates...");
      this.addCommand({
        id: "parse-dates",
        name: "Parse Dates",
        callback: () => {
          this.parseDates();
        },
        hotkeys: [
          {
            modifiers: ["Alt"],
            key: "D"
          }
        ]
      });
      TimelinesParseDates.prototype.getEditor = function() {
        var view = this.app.workspace.getActiveViewOfType(obsidian.MarkdownView);
        if (!view || view.getMode() !== "source") {
          return null;
        }
        return view.sourceMode.cmEditor;
      };
    });
  }
  onunload() {
    return __async(this, null, function* () {
      console.log("Unloading plugin TimelinesParseDates...");
    });
  }
  parseDates() {
    return __async(this, null, function* () {
      let editor = this.getEditor();
      let cursor = editor.getCursor();
      editor.setSelection({ line: 0, ch: 0 }, { line: editor.lastLine(), ch: 0 });
      let selectedText = editor.getSelection();
      try {
        let d1 = selectedText.match(/data-date='.{1,4}-/)[0].slice(11, -1);
        let d2 = selectedText.match(/data-end='.{1,4}-/)[0].slice(10, -1);
        let type = selectedText.match(/data-class='.*'/)[0].slice(12, -1);
        if (type.slice(0, 6) == "person") {
          var newString = "\nGeburtsdatum:: " + d1 + "\n\nTod:: " + d2 + "\n</span>";
        } else if (type.slice(0, 6) == "geschi" || type == "periode") {
          newString = "\nStart:: " + d1 + "\n\nEnde:: " + d2 + "\n</span>";
        }
        selectedText = selectedText.replace("</span>", newString);
        editor.replaceSelection(selectedText, "around");
        cursor.line += 4;
      } catch (e) {
      } finally {
        editor.setCursor(cursor);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xudmFyIG9ic2lkaWFuID0gcmVxdWlyZSgnb2JzaWRpYW4nKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lc1BhcnNlRGF0ZXMgZXh0ZW5kcyBQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyBjb25zdCBwb3RzX25hbWVzID0gW1wiQmVzb3JndW5nXCIsXCJFaW5rYXVmXCIsXCJGcmVpXCIsXCJHZWxkXCIsXCJJbnRha2VcIixcIlNvbnN0aWdlc1wiLFwiV2llZGVyaG9sdW5nXCJdXG4gICAgfVxuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBwbHVnaW4gVGltZWxpbmVzUGFyc2VEYXRlcy4uLicpO1xuXG4gICAgICAgIC8vIFRoaXMgYWRkcyBhbiBlZGl0b3IgY29tbWFuZCB0aGF0IGNhbiBwZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG9uIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdwYXJzZS1kYXRlcycsXG4gICAgICAgICAgICBuYW1lOiAnUGFyc2UgRGF0ZXMnLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRGF0ZXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBob3RrZXlzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFsnQWx0J10sXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ0QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIFRpbWVsaW5lc1BhcnNlRGF0ZXMucHJvdG90eXBlLmdldEVkaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShvYnNpZGlhbi5NYXJrZG93blZpZXcpO1xuICAgICAgICAgICAgaWYgKCF2aWV3IHx8IHZpZXcuZ2V0TW9kZSgpICE9PSAnc291cmNlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZpZXcuc291cmNlTW9kZS5jbUVkaXRvcjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBvbnVubG9hZCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1VubG9hZGluZyBwbHVnaW4gVGltZWxpbmVzUGFyc2VEYXRlcy4uLicpO1xuICAgIH1cblxuICAgIGFzeW5jIHBhcnNlRGF0ZXMoKSB7XG4gICAgICAgIC8vIEdldCBzcGFuIGJsb2NrXG4gICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLmdldEVkaXRvcigpO1xuXG4gICAgICAgIGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICAgICAgZWRpdG9yLnNldFNlbGVjdGlvbih7IGxpbmU6IDAsIGNoOiAwIH0sIHsgbGluZTogZWRpdG9yLmxhc3RMaW5lKCksIGNoOiAwIH0pXG4gICAgICAgIGxldCBzZWxlY3RlZFRleHQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgbGV0IGQxID0gc2VsZWN0ZWRUZXh0Lm1hdGNoKC9kYXRhLWRhdGU9Jy57MSw0fS0vKVswXS5zbGljZSgxMSwgLTEpXG4gICAgICAgICAgICBsZXQgZDIgPSBzZWxlY3RlZFRleHQubWF0Y2goL2RhdGEtZW5kPScuezEsNH0tLylbMF0uc2xpY2UoMTAsIC0xKVxuICAgICAgICAgICAgbGV0IHR5cGUgPSBzZWxlY3RlZFRleHQubWF0Y2goL2RhdGEtY2xhc3M9Jy4qJy8pWzBdLnNsaWNlKDEyLCAtMSlcblxuICAgICAgICAgICAgLy8gVHJlbm5lIGdlc2NoaSwgcGVyc29uXG4gICAgICAgICAgICBpZiAodHlwZS5zbGljZSgwLCA2KSA9PSBcInBlcnNvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0cmluZyA9ICdcXG5HZWJ1cnRzZGF0dW06OiAnICsgZDEgKyAnXFxuXFxuVG9kOjogJyArIGQyICsgJ1xcbjwvc3Bhbj4nXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc2xpY2UoMCwgNikgPT0gXCJnZXNjaGlcIiB8fCB0eXBlID09IFwicGVyaW9kZVwiKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyaW5nID0gJ1xcblN0YXJ0OjogJyArIGQxICsgJ1xcblxcbkVuZGU6OiAnICsgZDIgKyAnXFxuPC9zcGFuPidcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRlx1MDBGQ2dlIGRlbiBlbnRzcHJlY2hlbmRlbiBUZXh0IGFucyBFbmRlIGFuLlxuICAgICAgICAgICAgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0ZWRUZXh0LnJlcGxhY2UoJzwvc3Bhbj4nLCBuZXdTdHJpbmcpXG5cbiAgICAgICAgICAgIC8vIEFkZCBkYXRlcyBhdCByaWdodCBsb2NhdGlvblxuICAgICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oc2VsZWN0ZWRUZXh0LCAnYXJvdW5kJyk7XG4gICAgICAgICAgICBjdXJzb3IubGluZSArPSA0XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlKVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUE0RjtBQUM1RixJQUFJLFdBQVcsUUFBUTtBQUN2Qix3Q0FBaUQsdUJBQU87QUFBQSxFQUNwRCxjQUFjO0FBQ1YsVUFBTSxHQUFHO0FBQUE7QUFBQSxFQUlQLFNBQVM7QUFBQTtBQUNYLGNBQVEsSUFBSTtBQUdaLFdBQUssV0FBVztBQUFBLFFBQ1osSUFBSTtBQUFBLFFBQ0osTUFBTTtBQUFBLFFBQ04sVUFBVSxNQUFNO0FBQ1osZUFBSztBQUFBO0FBQUEsUUFFVCxTQUFTO0FBQUEsVUFDTDtBQUFBLFlBQ0ksV0FBVyxDQUFDO0FBQUEsWUFDWixLQUFLO0FBQUE7QUFBQTtBQUFBO0FBS2pCLDBCQUFvQixVQUFVLFlBQVksV0FBVztBQUNqRCxZQUFJLE9BQU8sS0FBSyxJQUFJLFVBQVUsb0JBQW9CLFNBQVM7QUFDM0QsWUFBSSxDQUFDLFFBQVEsS0FBSyxjQUFjLFVBQVU7QUFDdEMsaUJBQU87QUFBQTtBQUVYLGVBQU8sS0FBSyxXQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJekIsV0FBVztBQUFBO0FBQ2IsY0FBUSxJQUFJO0FBQUE7QUFBQTtBQUFBLEVBR1YsYUFBYTtBQUFBO0FBRWYsVUFBSSxTQUFTLEtBQUs7QUFFbEIsVUFBSSxTQUFTLE9BQU87QUFDcEIsYUFBTyxhQUFhLEVBQUUsTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLE1BQU0sT0FBTyxZQUFZLElBQUk7QUFDdkUsVUFBSSxlQUFlLE9BQU87QUFFMUIsVUFBRztBQUNDLFlBQUksS0FBSyxhQUFhLE1BQU0sc0JBQXNCLEdBQUcsTUFBTSxJQUFJO0FBQy9ELFlBQUksS0FBSyxhQUFhLE1BQU0scUJBQXFCLEdBQUcsTUFBTSxJQUFJO0FBQzlELFlBQUksT0FBTyxhQUFhLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxJQUFJO0FBRzlELFlBQUksS0FBSyxNQUFNLEdBQUcsTUFBTSxVQUFVO0FBQzlCLGNBQUksWUFBWSxzQkFBc0IsS0FBSyxlQUFlLEtBQUs7QUFBQSxtQkFDeEQsS0FBSyxNQUFNLEdBQUcsTUFBTSxZQUFZLFFBQVEsV0FBVztBQUMxRCxzQkFBWSxlQUFlLEtBQUssZ0JBQWdCLEtBQUs7QUFBQTtBQUl6RCx1QkFBZSxhQUFhLFFBQVEsV0FBVztBQUcvQyxlQUFPLGlCQUFpQixjQUFjO0FBQ3RDLGVBQU8sUUFBUTtBQUFBLGVBRWIsR0FBTjtBQUFBLGdCQUdBO0FBQ0ksZUFBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==
